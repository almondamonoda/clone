<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>„Å∂„Éº„Éº„Çì„É≠„Éº„Éâ</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "Segoe UI", "Hiragino Kaku Gothic ProN", sans-serif;
      background: radial-gradient(circle at top, #20314a 0%, #0b1018 55%, #05070b 100%);
      min-height: 100vh;
      display: grid;
      place-items: center;
      color: #eaf6ff;
    }
    .game-shell {
      width: min(94vw, 460px);
      display: grid;
      gap: 10px;
    }
    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid #355a7e;
      background: rgba(17, 28, 42, 0.9);
      border-radius: 10px;
      padding: 10px 12px;
      font-weight: 700;
    }
    .hud span { color: #91d0ff; font-size: 0.85rem; }
    canvas {
      width: 100%;
      aspect-ratio: 9/16;
      border-radius: 12px;
      border: 2px solid #3d5d7f;
      background: #1d1d1d;
      touch-action: none;
      box-shadow: 0 0 30px rgba(70, 140, 255, 0.2);
    }
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    button {
      border: 1px solid #527ba5;
      background: rgba(20, 36, 54, 0.95);
      color: #eaf6ff;
      border-radius: 10px;
      padding: 10px;
      font-weight: 700;
      font-size: 0.95rem;
    }
    .tip {
      font-size: 0.82rem;
      line-height: 1.5;
      color: #b6d9f4;
      text-align: center;
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <main class="game-shell">
    <div class="hud">
      <div>üèÅ Ë∑ùÈõ¢: <span id="distance">0m</span></div>
      <div>üí• „ÇØ„É©„ÉÉ„Ç∑„É•: <span id="crash">0</span></div>
      <div>‚ö° ÈÄüÂ∫¶: <span id="speed">0</span></div>
    </div>
    <canvas id="race" width="360" height="640" aria-label="„É¨„Éº„Çπ„Ç≤„Éº„É†"></canvas>
    <div class="controls">
      <button id="left">‚¨Ö Â∑¶„Å∏</button>
      <button id="right">Âè≥„Å∏ ‚û°</button>
    </div>
    <p class="tip">„Éû„É™„Ç™„Ç´„Éº„ÉàÈ¢®„Å´„Äå„Å∂„Éº„Éº„Çì„Äç„Åó„Çà„ÅÜ„ÄÇÈÅìË∑Ø„ÇíÂ§ñ„Çå„Çã„Å®„Ç¨„Çø„Ç¨„ÇøÊåØÂãïÔºàËß¶Ë¶öÔºâÔºÅ</p>
  </main>

  <script>
    const canvas = document.getElementById("race");
    const ctx = canvas.getContext("2d");
    const distanceEl = document.getElementById("distance");
    const crashEl = document.getElementById("crash");
    const speedEl = document.getElementById("speed");

    const state = {
      carX: canvas.width / 2,
      roadCenter: canvas.width / 2,
      roadHalf: 95,
      speed: 5,
      distance: 0,
      crashes: 0,
      stripeOffset: 0,
      steering: 0,
      obstacles: [],
      tick: 0,
    };

    const car = { width: 48, height: 80, y: canvas.height - 120 };

    function buzz(pattern = 20) {
      if (navigator.vibrate) navigator.vibrate(pattern);
    }

    function spawnObstacle() {
      const lane = (Math.random() - 0.5) * (state.roadHalf * 1.45);
      state.obstacles.push({
        x: state.roadCenter + lane,
        y: -40,
        size: 30 + Math.random() * 25,
      });
    }

    function drawRoad() {
      const horizon = 80;
      const curve = Math.sin(state.tick * 0.01) * 70;
      state.roadCenter = canvas.width / 2 + curve;

      ctx.fillStyle = "#3d8d48";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#2b2b2b";
      ctx.beginPath();
      ctx.moveTo(state.roadCenter - state.roadHalf * 0.4, horizon);
      ctx.lineTo(state.roadCenter + state.roadHalf * 0.4, horizon);
      ctx.lineTo(state.roadCenter + state.roadHalf, canvas.height);
      ctx.lineTo(state.roadCenter - state.roadHalf, canvas.height);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "#f4f4f4";
      ctx.lineWidth = 4;
      ctx.setLineDash([20, 18]);
      ctx.lineDashOffset = -state.stripeOffset;
      ctx.beginPath();
      ctx.moveTo(state.roadCenter, horizon);
      ctx.lineTo(state.roadCenter, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.strokeStyle = "#e8d66a";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(state.roadCenter - state.roadHalf * 0.4, horizon);
      ctx.lineTo(state.roadCenter - state.roadHalf, canvas.height);
      ctx.moveTo(state.roadCenter + state.roadHalf * 0.4, horizon);
      ctx.lineTo(state.roadCenter + state.roadHalf, canvas.height);
      ctx.stroke();
    }

    function drawCar() {
      ctx.save();
      ctx.translate(state.carX, car.y);

      ctx.fillStyle = "#1fa0ff";
      ctx.fillRect(-car.width / 2, -car.height / 2, car.width, car.height);

      // antennae (Ëß¶Ëßí„Å£„ÅΩ„ÅÑÈ£æ„Çä)
      ctx.strokeStyle = "#d7ecff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-10, -car.height / 2);
      ctx.lineTo(-18, -car.height / 2 - 18);
      ctx.moveTo(10, -car.height / 2);
      ctx.lineTo(18, -car.height / 2 - 18);
      ctx.stroke();

      ctx.fillStyle = "#ff5a5a";
      ctx.fillRect(-16, -18, 32, 26);
      ctx.fillStyle = "#111";
      ctx.fillRect(-20, -36, 12, 16);
      ctx.fillRect(8, -36, 12, 16);
      ctx.fillRect(-20, 20, 12, 16);
      ctx.fillRect(8, 20, 12, 16);
      ctx.restore();
    }

    function drawObstacle(ob) {
      ctx.fillStyle = "#d94343";
      ctx.fillRect(ob.x - ob.size / 2, ob.y - ob.size / 2, ob.size, ob.size);
      ctx.fillStyle = "#320000";
      ctx.fillRect(ob.x - ob.size / 4, ob.y - ob.size / 4, ob.size / 2, ob.size / 2);
    }

    function update() {
      state.tick++;
      state.speed = Math.min(12, 5 + state.distance / 450);
      state.stripeOffset += state.speed * 1.8;
      state.distance += state.speed * 0.8;

      state.carX += state.steering * (4 + state.speed * 0.35);

      const roadLeft = state.roadCenter - state.roadHalf + 16;
      const roadRight = state.roadCenter + state.roadHalf - 16;
      const offRoad = state.carX < roadLeft || state.carX > roadRight;

      if (offRoad) {
        state.carX = Math.max(roadLeft - 18, Math.min(roadRight + 18, state.carX));
        state.distance = Math.max(0, state.distance - 1.5);
        if (state.tick % 12 === 0) buzz([10, 30, 10]);
      }

      if (Math.random() < 0.02 + state.speed * 0.0015) spawnObstacle();

      const carLeft = state.carX - car.width / 2;
      const carRight = state.carX + car.width / 2;
      const carTop = car.y - car.height / 2;
      const carBottom = car.y + car.height / 2;

      state.obstacles.forEach((ob) => {
        ob.y += state.speed * 1.9;
        const hit =
          carLeft < ob.x + ob.size / 2 &&
          carRight > ob.x - ob.size / 2 &&
          carTop < ob.y + ob.size / 2 &&
          carBottom > ob.y - ob.size / 2;

        if (hit) {
          state.crashes++;
          buzz([50, 50, 90]);
          ob.y = canvas.height + 100;
          state.distance = Math.max(0, state.distance - 35);
        }
      });

      state.obstacles = state.obstacles.filter((ob) => ob.y < canvas.height + 60);

      distanceEl.textContent = `${Math.floor(state.distance)}m`;
      crashEl.textContent = String(state.crashes);
      speedEl.textContent = `${state.speed.toFixed(1)}km/h`;
    }

    function render() {
      drawRoad();
      state.obstacles.forEach(drawObstacle);
      drawCar();
    }

    function loop() {
      update();
      render();
      requestAnimationFrame(loop);
    }

    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") state.steering = -1;
      if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") state.steering = 1;
    });

    window.addEventListener("keyup", (e) => {
      if (["ArrowLeft", "ArrowRight", "a", "d", "A", "D"].includes(e.key)) state.steering = 0;
    });

    const leftBtn = document.getElementById("left");
    const rightBtn = document.getElementById("right");

    function bindSteerButton(button, value) {
      button.addEventListener("pointerdown", () => (state.steering = value));
      button.addEventListener("pointerup", () => (state.steering = 0));
      button.addEventListener("pointercancel", () => (state.steering = 0));
      button.addEventListener("pointerleave", () => (state.steering = 0));
    }

    bindSteerButton(leftBtn, -1);
    bindSteerButton(rightBtn, 1);

    loop();
  </script>
</body>
</html>
